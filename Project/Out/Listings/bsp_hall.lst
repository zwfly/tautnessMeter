C51 COMPILER V9.56.0.0   BSP_HALL                                                          10/13/2017 21:21:43 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE BSP_HALL
OBJECT MODULE PLACED IN .\Out\Objects\bsp_hall.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\Bsp\src\bsp_hall.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Common\in
                    -c;..\App\inc;..\Bsp\inc;..\Startup;..\Bsp) DEFINE(FOSC_110592) DEBUG OBJECTEXTEND PRINT(.\Out\Listings\bsp_hall.lst) OBJ
                    -ECT(.\Out\Objects\bsp_hall.obj)

line level    source

   1          /*
   2           * bsp_hall.c
   3           *
   4           *  Created on: 2017年6月26日
   5           *      Author: fly
   6           */
   7          
   8          #include "bsp.h"
   9          #include "app_work.h"
  10          #include "bsp_beep.h"
  11          #include "app_key.h"
  12          #include <string.h>
  13          
  14          #define HALL_NUM  3
  15          #define HALL_CNT_UP  12
  16          #define HALL_CNT_DOWN  5
  17          
  18          static uint8_t i = 0;
  19          
  20          static HALL_T g_tHall;
  21          #if 0
              static idata uint8_t fifoBuf[8] = {0};
              #else
  24          static uint8_t fifoBuf[8] = { 0 };
  25          #endif
  26          static void Hall_InitHard(void) {
  27   1      
  28   1              P5M1 &= ~ SET_BIT4;
  29   1              P5M2 |= SET_BIT4;
  30   1      
  31   1      //      app_powerKeyInt_close();
  32   1      
  33   1              bsp_hallInt_open();
  34   1      
  35   1              set_EPI;
  36   1      }
  37          static void Hall_InitVar(void) {
  38   1              g_tHall.count = 0;
  39   1              g_tHall.direction = 0;
  40   1              g_tHall.lastPos = 0;
  41   1      
  42   1              memset(fifoBuf, 0, sizeof(fifoBuf));
  43   1      }
  44          
  45          void bsp_hallInt_open(void) {
  46   1      
  47   1              P54 = 0;
  48   1      
  49   1              set_PIPS2;
  50   1              clr_PIPS1;
  51   1              set_PIPS0;
  52   1      
  53   1              clr_PIT0;
C51 COMPILER V9.56.0.0   BSP_HALL                                                          10/13/2017 21:21:43 PAGE 2   

  54   1              set_PIT1;
  55   1              set_PIT2;
  56   1              set_PIT3;
  57   1              clr_PIT4;
  58   1              clr_PIT5;
  59   1              clr_PIT6;
  60   1              clr_PIT7;
  61   1      
  62   1              clr_PINEN0;
  63   1              set_PINEN1;
  64   1              set_PINEN2;
  65   1              set_PINEN3;
  66   1              clr_PINEN4;
  67   1              clr_PINEN5;
  68   1              clr_PINEN6;
  69   1              clr_PINEN7;
  70   1      
  71   1              PIPEN = 0x00;
  72   1              clr_PIPEN1;
  73   1              clr_PIPEN2;
  74   1              clr_PIPEN3;
  75   1      
  76   1      }
  77          void bsp_hallInt_close(void) {
  78   1      
  79   1              P54 = 1;
  80   1      
  81   1              clr_PIT1;
  82   1              clr_PIT2;
  83   1              clr_PIT3;
  84   1      
  85   1              clr_PINEN1;
  86   1              clr_PINEN2;
  87   1              clr_PINEN3;
  88   1      }
  89          void Hall_Init(void) {
  90   1              Hall_InitHard();
  91   1              Hall_InitVar();
  92   1      }
  93          
  94          void bsp_hall_1s_pro(void) {
  95   1      
  96   1              printf("meter count %d\n", (int) g_tHall.count);
  97   1      
  98   1      }
  99          
 100          //123 拉长
 101          void hall_pro(uint8_t n) {
 102   1              static BIT valid_flag = 0;
 103   1              static uint8_t hall_init_cnt = 0;
 104   1      
 105   1              noOps_timeoutCnt = 0;
 106   1              lcd_bright_on();
 107   1      
 108   1              if (hall_init_cnt < 7) {
 109   2                      hall_init_cnt++;
 110   2              }
 111   1      
 112   1              for (i = (sizeof(fifoBuf) - 2); i >= 0; i--) {
 113   2                      fifoBuf[i + 1] = fifoBuf[i];
 114   2              }
 115   1              fifoBuf[0] = n;
C51 COMPILER V9.56.0.0   BSP_HALL                                                          10/13/2017 21:21:43 PAGE 3   

 116   1              switch (n) {
 117   2              case 0:
 118   2                      if (g_tHall.lastPos == 0) {
 119   3                              if (g_tHall.direction) {
 120   4                                      g_tHall.direction = 0;
 121   4                              } else {
 122   4                                      g_tHall.direction = 1;
 123   4                              }
 124   3                      } else if (g_tHall.lastPos == 1) {
 125   3                              g_tHall.direction = 0;
 126   3                      } else if (g_tHall.lastPos == 2) {
 127   3                              g_tHall.direction = 1;  //拉长
 128   3                      }
 129   2                      break;
 130   2              case 1:
 131   2                      if (g_tHall.lastPos == 1) {
 132   3                              if (g_tHall.direction) {
 133   4                                      g_tHall.direction = 0;
 134   4                              } else {
 135   4                                      g_tHall.direction = 1;
 136   4                              }
 137   3                      } else if (g_tHall.lastPos == 2) {
 138   3                              g_tHall.direction = 0;
 139   3                      } else if (g_tHall.lastPos == 0) {
 140   3                              g_tHall.direction = 1;  //拉长
 141   3                      }
 142   2                      break;
 143   2              case 2:
 144   2                      if (g_tHall.lastPos == 2) {
 145   3                              if (g_tHall.direction) {
 146   4                                      g_tHall.direction = 0;
 147   4                              } else {
 148   4                                      g_tHall.direction = 1;
 149   4                              }
 150   3                      } else if (g_tHall.lastPos == 0) {
 151   3                              g_tHall.direction = 0;
 152   3                      } else if (g_tHall.lastPos == 1) {
 153   3                              g_tHall.direction = 1;  //拉长
 154   3                      }
 155   2                      break;
 156   2              }
 157   1      #if 1
 158   1              if ((fifoBuf[0] == 2) && (fifoBuf[0] == 0) && (fifoBuf[0] == 2)) {
 159   2      
 160   2              }
 161   1      #endif
 162   1              g_tHall.lastPos = n;
 163   1              if (g_tHall.direction) {
 164   2                      g_tHall.count++;
 165   2              } else {
 166   2                      g_tHall.count--;
 167   2              }
 168   1              if (valid_flag) {
 169   2                      if (g_tHall.count < HALL_CNT_DOWN) {
 170   3                              valid_flag = 0;
 171   3                      }
 172   2              } else {
 173   2                      if (g_tHall.count > HALL_CNT_UP) {
 174   3                              valid_flag = 1;
 175   3                              /* your code   --start */
 176   3                              // 拉一次计数一次，计数一次调用一次
 177   3                              query_work_sum();
C51 COMPILER V9.56.0.0   BSP_HALL                                                          10/13/2017 21:21:43 PAGE 4   

 178   3                              /* your code   --end */
 179   3                      }
 180   2              }
 181   1      
 182   1      }
 183          
 184          void hall_1_interrupt(void) {
 185   1              hall_pro(0);
 186   1      }
 187          void hall_2_interrupt(void) {
 188   1              hall_pro(1);
 189   1      }
 190          void hall_3_interrupt(void) {
 191   1              hall_pro(2);
 192   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    436    ----
   CONSTANT SIZE    =     16    ----
   XDATA SIZE       =     13       1
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
